// <copyright file="IgnoreGeneratedFilesBuildTask.cs" company="Dark Bond, Inc.">
//    Copyright © 2016-2017 - Dark Bond, Inc.  All Rights Reserved.
// </copyright>
// <author>Donald Roy Airey</author>
namespace DarkBond.Tools
{
    using System;
    using System.IO;
    using Microsoft.Build.Framework;
    using Microsoft.Build.Utilities;

    /// <summary>
    /// Will modify the intermediate (generated) source files so they won't be parsed for documentation errors.
    /// </summary>
    public class IgnoreGeneratedFilesBuildTask : Task
    {
        /// <summary>
        /// Used to describe the files in the intermediate directory that will be exempt from the analysis tools.
        /// </summary>
        private const string SearchPattern = "*.cs";

        /// <summary>
        /// Gets or sets the intermediate path for the output files.
        /// </summary>
        /// <value>
        /// The intermediate path for the output files.
        /// </value>
        [Required]
        public string IntermediateOutputPath
        {
            get; set;
        }

        /// <summary>
        /// Executes a task.
        /// </summary>
        /// <returns>True if the task executed successfully; otherwise, false.</returns>
        public override bool Execute()
        {
            // Recurse into the directory structure looking for intermediate files which need directives to ignore XML comment violations.
            this.RecurseIntoDirectory(new DirectoryInfo(this.IntermediateOutputPath));

            // We're done here.
            return true;
        }

        /// <summary>
        /// Recurse into the directory structure looking for files which need compiler directives to ignore XML comment violations.
        /// </summary>
        /// <param name="directoryInfo">The current directory level.</param>
        private void RecurseIntoDirectory(DirectoryInfo directoryInfo)
        {
            // This is the recursion part.  Look into every subdirectory at the current level for files that need the compiler directive.
            foreach (DirectoryInfo subDirectoryInfo in directoryInfo.EnumerateDirectories())
            {
                this.RecurseIntoDirectory(subDirectoryInfo);
            }

            // At the current directory level, look for intermediate files and add the directive that will inhibit the check for comments.
            foreach (FileInfo fileInfo in directoryInfo.EnumerateFiles(IgnoreGeneratedFilesBuildTask.SearchPattern))
            {
                // Read the entire file into a string buffer.
                string fileContent = File.ReadAllText(fileInfo.FullName);

                // Don't add the pragma if the code has already been modified.
                if (!fileContent.StartsWith("#pragma warning disable 1591", StringComparison.Ordinal))
                {
                    // If this module has been auto-generated (and hasn't already been modified), then add the directives at the start and end of the
                    // document that will prevent any documentation errors from kicking out of the analyzer.
                    if (fileContent.Contains("<auto-generated>"))
                    {
                        fileContent = "#pragma warning disable 1591\n" + fileContent + "#pragma warning restore 1591";
                        File.WriteAllText(fileInfo.FullName, fileContent);
                    }
                }
            }
        }
    }
}